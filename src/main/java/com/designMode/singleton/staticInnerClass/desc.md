[深入理解jvm--Java类的初始化及主动引用和被动引用完全解析](https://blog.csdn.net/u013309870/article/details/73005868)

## 初始化
类初始化阶段是类加载过程的最后一步，之前的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。
到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。
初始化阶段是执行类构造器 <clinit>() 方法的过程。

## 主动引用

> 对类进行引用时如果类没有进行过初始化，则先触发其初始化叫做主动引用。
> 有且只有下面五种情况下才会进行主动引用。

1. 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
    生成这四条指令的常见 Java 代码场景是：
    1. 使用 new 关键字实例化对象的时候。
    2. 读取一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
    3. 设置一个类的静态字段的时候
    4. 调用一个类的静态方法的时候。
2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。
5. 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

## 被动引用

> 对于上面五种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这五种场景中的行为称为对一个类进行主动引用。
> 除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

1. 通过子类引用父类的静态字段，不会导致子类初始化。
2. 通过数组定义来引用类，不会触发此类的实例化。
3. 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
